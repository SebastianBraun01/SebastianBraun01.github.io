<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/artikel.css">
  <title>LED-Matrix | Sebastian Braun</title>
</head>

<body>
  <!-- Navbar mit Logo -->
  <header id="haupt-nav" class="schatten">
    <div id="logo-container">
      <img src="../img/logo_hell.png" height="65" alt="Logo" >
    </div>

    <nav>
      <li class="nav-link"><a class="link-text" href="../index.html">Home</a></li>
      <li class="nav-link"><a class="link-text" href="#" id="dropdown"><span id="dropdown_icon">+</span>Projekte</a></li>
      <li class="nav-link"><a class="link-text" href="../pages/√ºbermich.html">√úber mich</a></li>
      <li class="nav-link"><a class="link-text" href="https://github.com/SebastianBraun01" target="_blank"><img src="../img/github-logo.png" width="40"><span>GitHub</span></a></li>
    </nav>

    <script defer src="../ts/out/navigation.js"></script>
  </header>
  

  <!-- Hauptseite -->
  <main>
    <section id="Kopf">
      <h1>LED-Matrix</h1>
      <img src="" alt="Foto noch einf√ºgen">
    </section>

    <section id="Beschreibung">
      <p>Die LED Matrix geh√∂rt technisch gesehen, noch zu meinem anderen Projekt, der LED Beleuchtung, hat aber mitlerweile eine solche komplexit√§t erreicht, dass es sinnvol ist sie hier nochmal ausf√ºhrlich zu beschreiben. Die LED Matrix wird ein tolles Gimmik f√ºr unseren Partykeller, unzwar ein riesiger Audio Spektrograph. Die Steuerung der Matrix wird dann mit dem Mischpult unserer Surround-Anlage verbunden und zeigt in verschiedenen Formen und Farben das Frequenzspektrum der Musik.</p>
      <br>
      <br>
      <h1>Hardware</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Matrix wird noch gebaut (to be continued).</p>
      <br>
      <br>
      <img src="../img/matrix_konstruktion.png" alt="Bild der CAD Konstruktion" width="1200">
      <br>
      <br>
      <img src="" alt="Bild der Verkabelung">
      <br>
      <br>
      <h1>Audio Sampling</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Die Musik muss so vorbereitet werden, dass sie von den AD-Wandlern des Arduinos gemessen und verarbeitet werden kann. Der Arduino hat einen Messbereich von 0V bis 5V und kann keine negativen Spannungen messen. Der Klinkenstecker eines Handys schafft etwa ¬±150mV. Ich hab also einen Audio Verst√§rker entworfen, der die Spitzen von bis zu 150mV auf Spitzen von bis zu 2.5V verst√§rken kann und der Ausgangsspannung einen Grundanteil von 2.5V gibt. Somit bewegt sich die Spannung innerhalb und um den Mittelpunkt des Messbereiches. Ich verwende einen ICL7660 Spannungsinvertierer/-converter um den Operationsverst√§rker zu versorgen.</p>
      <br>
      <br>
      <img src="../img/verst√§rker_schaltung.png" alt="Verst√§rkerschaltung" width="1100">
      <br>
      <br>
      <h1>Software</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Nun zur Steuerung, dem komplizierten Teil. Urspr√ºnglich ich die LED Matrix auch nur mit einem normalen Arduino betreiben. Daf√ºr habe ich von Adafruit eine FFT Bibliothek gefunden. Der "Fast Fourier Transform (FFT)" ist ein mathematischer Algorythmus, mit dem ein Computer oder Mikrocontroller aus den Messpunkten des Zeitsignal der Musik ein Frequenzspektrum berechnen kann, f√ºr mich also die charakteristischen Balken, die die Anteile der hohen und tiefen T√∂ne in der Musik anzeigen (auf den FFT Algorythmus m√∂chte ich in einem anderen Artikel noch genauer eingehen, die Projektbeschreibung wird hier so schon noch lang genug).</p>
      <br>
      <br>
      <p>Der Arduino sollte also die Messpunkte mit dem integrierten AD Wandler aufnehmen, diese mit dem FFT Algorythmus verarbeiten und das Ergebnis auf der Matrix ausgeben. Daf√ºr habe ich einen kleinen Prototypen gebaut. Dieser hat auch perfekt funktioniert.</p>
      <br>
      <br>
      <video src="../img/uv_prototyp.mp4" muted preload controls width="700"></video>
      <br>
      <br>
      <p>Diese Herangehensweise hat nur einen Haken. Je gr√∂√üer die Matrix wird, desto langsamer wird die ganze Rechnerei im Mikrocontroller, weil die Berechnungen und das Ansteuern der Matrix Zeit brauchen und nicht parallel ablaufen k√∂nnen. Mit diesem kleinen Prototypen funktioniert noch alles einwandfrei, aber wenn ich die Steuerung an die gro√üe Matrix h√§nge, wird das nur noch eine Diashow.</p>
      <br>
      <br>
      <p>Ein anderer Plan musste her und da bin ich auf FPGAs gekommen. Es gibt von Arduino n√§mlich den MKR Vidor 4000, ein Development Board auf dem ein Mikrocontroller (SAM21) und ein FPGA (Intel Cyclone 10) verbaut ist. Ein FPGA ist ideal f√ºr dieses Projekt, da ich alle Aufgaben (au√üer das samplen mit dem ADC) auf dem FPGA parallel betreiben und wie eine Pipeline behandeln kann und das mit einem noch viel h√∂hren Takt. Das ist vor allem f√ºr die Ansteuerung der Matrix wichtig, da ich jetzt nicht einen gro√üen Streifen ansteuern muss, der die Matrix bildet, sondern ich kann jetzt f√ºr jede einzelne Spalte der Matrix, einen seperaten Streifen benutzen und diese alle komplett parallel ansteuern und das mit bis zu 200MHz (ist ein bischen √ºbertrieben, aber m√∂glich üòé). Auf dem Arduino gibt es ein 24MHz Taktsignal f√ºr den FPGA, dieses hat bis jetzt f√ºr die Berechnungen gereicht.</p>
      <br>
      <br>
      <img src="../img/vidor.jpg" alt="Arduino MKR Vidor 4000" width="400">
      <br>
      <br>
      <p>Um den FPGA zu programmieren, benutze ich Verilog, ich bin zwar √ºber die Hochschule auch mit VHDL vertraut aber ich finde den Syntax von Verilog wesentlich besser und ich mag die N√§he zur C Programmiersprache. Ich habe das Programm f√ºr den FPGA auf mehrere Module aufgeteilt:</p>
      <br>
      <br>
      <ul>
        <li>npxl_treiber:     Treibermodul f√ºr die LED Streifen</li>
        <li>npxl_controller:  Liest Farbdaten ein und gibt sie √ºber die Streifen aus</li>
        <li>ROM:              Speichert momentan feste Farbmuster f√ºr die Balkenanzeige des FFT Outputs</li>
        <li>RAM:              Blockram als Zwischenspeicher f√ºr FFT Werte</li>
        <li>uart_rx:          UART Empf√§nger um ADC Daten vom Mikrocontroller zu empfangen</li>
        <li>FFT:              FFT Megafunktion (von Gisselquist, Link unten)</li>
        <li>spektrometer:     Top Modul f√ºr das FPGA programm, bindet alle ben√∂tigten Sub Module ein</li>
      </ul>
      <br>
      <br>
      <img src="" alt="Diagramm vom Programmaufbau">
      <br>
      <br>
      <h1>Neopixel Treiber</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Die Basis der Anzeige ist der npxl_treiber. Dieses Modul lie√üt den 24Bit Farbcode LED f√ºr LED ein und zeigt ihn an, ist das Ende des Streifens errecht wird die Datenleitung f√ºr 50¬µs auf Null gesetzt um die Daten in den LEDs zu best√§tigen. Im inneren des Moduls l√§uft eine Automatenkonstrukt, das das lesen und senden der einzelnen Bits koordiniert.<br>
      Wird der die send-Leitung aktiviert, legt der Block eine Speicheradresse an, die der LED entspricht, deren Daten der Block braucht. Die Farbdaten, die am Eingang anliegen werden in ein Puffer-Register eingelesen. In der Definition des Blocks im Parent-Modul wird dem Block fest vorgegeben, wie viele LEDs er abarbeiten muss.</p>
      <br>
      <br>
      <p>Nun looped der Block √ºber die Speicheradressen und gibt deren Inhalt an die LED-Streifen aus. F√ºr jedes Bit, das ausgegeben wird, gibt es timing Bedingungen, die bestimmen ob eine 1 oder 0 gesendet wird. Diese Zeiten k√∂nnen dem Datenblatt entnommen werden.<br>
      F√ºrs erste wird an den Treiberblock nur ein ROM angeschlossen sein, das feste Farbdaten enth√§lt, aber zul√§sst, dass nur LEDs bis zu einer bestimmten H√∂he erleuchtet werden.</p>
      <br>
      <br>
      <iframe src="../img/npxl_treiber_rtl.pdf" width="1000" height="500">Blockdarstellung: npxl_treiber</iframe>
      <br>
      <br>
      <iframe src="../img/ws2812b_datasheet.pdf" width="1000" height="800">Datenblatt WS2812B</iframe>
      <br>
      <br>
      <h1>Neopixel Controller</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Der npxl_controller importiert den npxl_treiber und ein ROM Modul. Die Au√üf√ºhrung dieses Modul kann sich in der Zukunft noch √§ndert, aber in seiner jetzigen Form lie√üt es einen H√∂henwert ein (also den Pegel der Musik) und l√§sst von unten hoch dementsprechend viele LEDs mit einer festen Farbe leuchten, w√§hrend es die LEDs dar√ºber ausschaltet. So habe ich meine Pegelanzeige f√ºr die FFT Megafunktion. Die Farbdaten werden von dem ROM gelesen. Ist die H√∂he erreicht, die ich anzeigen will, wird der Adresse des npxl_treiber ein Offset hinzugef√ºgt, das den Block einen anderen Adressraum des ROMs lesen l√§sst, wo nur Nullen drinstehen, also die LEDs ausschalten.</p>
      <br>
      <br>
      <iframe src="../img/npxl_controller_rtl.pdf" width="1000" height="500">Blockdarstellung: npxl_controller</iframe>
      <img src="" alt="Blockdarstellung vom npxl_controller">
      <br>
      <br>
      <h1>UART RX Modul</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Das uart_rx Modul ist daf√ºr zust√§ndig die Samples vom Mikrocontroller zu empfangen und √ºber ein Register zur FFT Megafunktion weiterzuleiten. Das Programm f√ºr UART ist eigentlich relativ einfach aufgebaut, was man zuerst nicht erwarten w√ºrde. Wenn es das UART Startbit erkennt erwartet es 8 Datenbits und pr√ºft dann ob ein Stopbit gesendet wurde um die √úbertragung zu best√§tigen. Wenn das geschehen ist liegen die Daten am Ausgangsregister an und ein data-valid Signal wird gesetzt. Intern wird die Koordination dieser Schritte √ºber ein Automatenkonstrukt geregelt.</p>
      <br>
      <br>
      <img src="../img/uart_protokoll.png" alt="UART Protokoll">
      <br>
      <br>
      <iframe src="../img/uart_rx_rtl.pdf" width="1000" height="500">Blockdarstellung: uart_rx</iframe>
      <br>
      <br>
      <h1>FFT Megafunktion</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Jetzt kommt das FFT Modul. Ersteinmal m√∂chte ich ein gro√ües Lob an Gisselquist aussprechen, der den eigentlichen FFT Kern entworfen hat und auf GitHub einen Generator f√ºr angepassbare FFT Kerne zu Verf√ºgung stellt. Auf seiner Webseite ist der Aufbau und die Funktionsweise des Kerns exellent beschrieben und ich bin froh, dass ich das Projekt gefunden habe. Ein Link zur seiner Seite ist unten. Aber nun zum Technischen. Das FFT Modul, das ich programmiert habe ist ein Wrapper um den FFT Kern herum, damit ich ein gewisses Ma√ü an Flowcontroll mit dem Kern habe und dass ich ihn in einer Burst Konfiguration benutzen kann, weil der eigentliche Kern als eine Pipeline ausgelegt ist. Einfach ausgedr√ºckt: Der Kern selbst erwartet eine gewisse Anzahl an Samples und rechnet kontinuierlich ab dem ersten Sample.</p>
      <br>
      <br>
      <p>Mit meinem Design wiederum wartet er nun bis er alle Samples f√ºr eine Berechnung hat (momentan 512), rechnet dann alles durch und gibt dann das komplette Ergebnis aus bevor er neue Samples empfangen kann, er rechnet also immer Etappenweise oder in einer Burst Konfiguration. Zus√§tzlich hat er noch Signale, die anzeigen wann er rechnet und wann Daten geschrieben und gelesen werden k√∂nnen. Als Input nimmt der Block 8 Bit breite Datensamples f√ºr jewails die Realen und Komplexen Werte, also 16 Bit. Die Komplexen Werte sind f√ºr meine Anwendung nicht relevant, da ich keine genauen Rechenwerte erzielen will, sondern nur einen tollen Effekt zur Musik.</p>
      <br>
      <br>
      <img src="" alt="Blockdarstellung vom FFT Modul">
      <br>
      <br>
      <h1>Spektrometer</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Das spektrometer Modul f√ºgt alle Bausteine zusammen und ist das Modul, das letztendlich auf den FPGA geflasht wird. Alle Module koordinieren sich untereinander mit Ready- und Startsignalen. Zwischen dem Output der FFT Funktion und den Eing√§ngen der npxl_controller befindet sich noch ein Verteiler, der einen Datensatz einlie√üt und diesem ausgew√§hlte Punkte entnimmt, die auf der Matrix angezeigt werden sollen, denn meine Matrix hat eine Breite von 32 Streifen und ich habe 512 Datenpunkte.</p>
      <br>
      <br>
      <h1>Sourcecode</h1>
      <div class="break"></div>
      <br>
      <br>
      <p>Das war jetzt eine ganz sch√∂ne Wand von Text. Ich hoffe das Projekt findet ein bischen Aufmerksamkeit auf GitHub und ich freue mich √ºber Kommentare und Verbesserungsvorschl√§ge. Das Repository ist unten verlinkt zusammen mit der Seite von Gisselquist. Schaut unbedingt mal auf seine Seite. Er hat den FFT Algorythmus ausf√ºhrlich und verst√§ndlich erkl√§rt.</p>
    </section>

    <section id="Links">
      <a class="Link-Button" href="https://github.com/SebastianBraun01/vu_meter" target="_blank">Projekt Repository</a>
      <a class="Link-Button" href="https://zipcpu.com/dsp/2018/10/02/fft.html" target="_blank">Gisselquist Seite</a>
      <a class="Link-Button" href="https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-use" target="_blank">Adafruit Seite</a>
    </section>
  </main>
</body>
</html>
